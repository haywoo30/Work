---
title: "Day 15 In Class Activity, Part 2"
author: "Vince Melfi"
date: "February 26, 2020"
output:
  html_document:
    number_sections: no
    theme: cerulean
---

```{r global_options, echo = FALSE}
knitr::opts_chunk$set(comment = NA, tidy = TRUE)
```


```{r echo = FALSE}
library(ggplot2)
```
In this ICA we investigate efficiency of R code. Turn the ICA in to D2L.

## Random Walks and Efficiency

(This is adapted from https://www.stat.auckland.ac.nz/~ihaka/downloads/Taupo.pdf.) Each second, a person moves one step either forward, backward, to the right, or to the left, with the same chance of moving in each of the four directions. This is an informal description of a very important random process called a *random walk*. The term *random walk* probably is best known to the public from the book "A Random Walk down Wall Street: The Time-tested Strategy for Successful Investing."

What is described is more properly called a *symmetric random walk* since the person has equal probabilities of moving in each of the four directions. For the rest of this ICA, the focus will be on this situation, so the word "symmetric" will usually be omitted from the name. 

Here is a slightly more formal description: A random process in two dimensions which, if currently at the point $(x,y)$, moves to one of $(x+1, y)$, $(x-1, y)$, $(x, y+1)$, or $(x, y-1)$ with equal probability for each of the four moves. The process is called a simple symmetric random walk in two dimensions. For simplicity we'll assume that the random walk starts at $(0,0)$. 

Here, for example, is an animation of the trajectory of the first 50 steps of a random walk.

![](https://www.stt.msu.edu/~melfi/STT180SS20/graphics/rw.gif)



Random walks in one, two, three, and higher dimensions are a central object in probability. There are many beautiful results about random walks, for example Polya's Theorem, which states that the simple symmetric random walk in one and two dimensions will, with probability one, return to its starting point, but in higher dimensions there is a positive probability that the random walk will NOT return to its starting point. In addition to such analytic results, it is useful to simulate random walks. That is the focus below.

Here is a relatively simple R function which simulates the first `n` steps of a simple random walk in two dimensions. The function returns a data frame with one column giving the $x$ coordinates and one column giving the $y$ coordinates of the walk. You may not be familiar with the `sample` function. Its first argument is a "population" vector of values from which to choose. Its second argument is the number of values to choose. Other arguments can specify whether sampling is performed with or without (the default) replacement, and can specify unequal sampling probabilities for each element of the population vector.

```{r}
rand_walk_1 <-
function(n) {
    ##Start at (0,0)
    xpos <- 0
    ypos <- 0
    ##Two vectors to sample from. One to determine whether the move 
    ##is horizontal or vertical. Another to determine whether the 
    ##move is +1 or -1 in the specified direction
    move_horiz = c(TRUE, FALSE)
    move_directions = c(1, -1)
    ##The loop which computes the moves
    for(i in 2:n){
      ##Check whether to move horizontally or vertically
      if (sample(move_horiz, 1)) {
        ##Make the move, either +1 or -1
        xpos[i] <- xpos[i-1] + sample(move_directions, 1)
        ypos[i] <- ypos[i-1]
      } ##If not horizontal, then vertical
    else {
      xpos[i] <- xpos[i-1]
      ypos[i] <- ypos[i-1] + sample(move_directions, 1)
    }
    }  
    ##return the full trajectory
    return(data.frame(xpos = xpos, ypos = ypos))
}
```

Here we look at the first ten positions of a simulated random walk, and then plot the moves for a 500 step walk. 

```{r}
set.seed(123)
rand_walk_1(10)
rw500 <- rand_walk_1(500)
ggplot(data = rw500, aes(x = xpos, y = ypos)) + geom_path() + geom_point(data = data.frame(x = 0, y = 0), aes(x = x, y = y), col = "green", size = 2) + geom_point(data = data.frame(x = rw500[500,1], y = rw500[500,2]), aes(x = x, y = y), col = "red", size = 2)
```

For comparison with subsequent, hopefully more efficient versions of the function, we'll measure how long it takes `rand_walk_1` to generate one million (`1e6`) steps of the random walk. The argument `cache = TRUE` is turned on. The first time through this will take several seconds, but subsequent times it will be much quicker. Focus on the third value returned, which is the elapsed time it took to generate one million steps.

You can use the following code, but in the next R code chunk, where it will actually be evaluated.

```{r eval = FALSE}
time1 <- system.time(rand_walk_1(1e6))
time1
```

(@) Use `system.time` to time `rand_walk_1` for `n = 1e6`. 

```{r, cache = TRUE}
#Time rand_walk_1 here
system.time(rand_walk_1(1e6))
```

Looking at `rand_walk_1` you will see a source of possible inefficiency. Rather than allocating all `n` elements of `xpos` and `ypos` initially, the function initializes each with one element, and then enlarges the vectors each pass through the `for` loop. 

(@) Create a new function `rand_walk_2` by changing `xpos <- 0` and `ypos <- 0` to `xpos <- numeric(n)` and `ypos <- numeric(n)`. This create a full vector of `n`  all `n` elements of `xpos` and `ypos` when these objects are created in the function.

```{r}
#Create rand_walk_2 here
rand_walk_2 <- function(n) {
    ## Start at (0,0)
    xpos <- numeric(n)
    ypos <- numeric(n)
    ## Two vectors to sample from. One to determine whether the move is horizontal or
    ## vertical. Another to determine whether the move is +1 or -1 in the specified
    ## direction
    move_horiz = c(TRUE, FALSE)
    move_directions = c(1, -1)
    ## The loop which computes the moves
    for (i in 2:n) {
        ## Check whether to move horizontally or vertically
        if (sample(move_horiz, 1)) 
            {
                ## Make the move, either +1 or -1
                xpos[i] <- xpos[i - 1] + sample(move_directions, 1)
                ypos[i] <- ypos[i - 1]
            }  ##If not horizontal, then vertical
 else {
            xpos[i] <- xpos[i - 1]
            ypos[i] <- ypos[i - 1] + sample(move_directions, 1)
        }
    }
    ## return the full trajectory
    return(data.frame(xpos = xpos, ypos = ypos))
}
```



(@) Use `system.time` to time `rand_walk_2` for `n = 1e6`. 


```{r cache = TRUE}
#Time rand_walk_2 here

system.time(rand_walk_2(1e6))/system.time(rand_walk_1(1e6))
```

(@) What is the ratio of elapsed time for `rand_walk_2` versus `rand_walk_1`?

Another place to look for a speedup is vectorization. Can we use vector operations instead of the "one at a time" looping construct? Let's sneak up on this in a few steps. First, instead of calling `sample` twice (once for horizontal versus vertical, and one for +1 versus -1) each time through the loop, we next call generate all horizontal versus vertical decisions  outside the loop, and use the resulting choices inside the loop. I've done this for vertical versus horizontal in `rand_walk_3` below. *Note that I had to be careful with indices inside the loop.*

```{r}
rand_walk_3 <-
  function(n) {
    xpos <- numeric(n)
    ypos <- numeric(n)
    ##Two vectors to sample from. One to determine whether the move 
    ##is horizontal or vertical. Another to determine whether the 
    ##move is +1 or -1 in the specified direction
    move_horiz = sample(c(TRUE, FALSE), n-1, replace = TRUE)
    move_directions = c(-1,1)
    ##The loop which computes the moves
    for(i in 2:n){
      ##Check whether to move horizontally or vertically
      if (move_horiz[i-1]) {
        ##Make the move, either +1 or -1
        xpos[i] <- xpos[i-1] + sample(move_directions, 1)
        ypos[i] <- ypos[i-1]
      } ##If not horizontal, then vertical
    else {
      xpos[i] <- xpos[i-1]
      ypos[i] <- ypos[i-1] + sample(move_directions, 1)
    }
    }  
    ##return the full trajectory
    return(data.frame(xpos = xpos, ypos = ypos))
  }
```

(@) Use `system.time` to time `rand_walk_3` for `n = 1e6`. 

```{r cache = TRUE}
#Time rand_walk_3 here
system.time(rand_walk_3(1e6))/system.time(rand_walk_1(1e6))
```

(@) What is the ratio of elapsed time for `rand_walk_3` versus `rand_walk_1`?

(@) Improve the speed even more by making a similar change for the choice of +1 or -1 moves. Call the resulting function `rand_walk_4`. 

```{r}
#Create rand_walk_4 here
rand_walk_4 <- function(n) {
    xpos <- numeric(n)
    ypos <- numeric(n)
    ## Two vectors to sample from. One to determine whether the move is horizontal or
    ## vertical. Another to determine whether the move is +1 or -1 in the specified
    ## direction
    move_horiz = sample(c(TRUE, FALSE), n - 1, replace = TRUE)
    move_directions = sample(c(-1,1),n-1,replace=TRUE)
    ## The loop which computes the moves
    for (i in 2:n) {
        ## Check whether to move horizontally or vertically
        if (move_horiz[i - 1]) 
            {
                ## Make the move, either +1 or -1
                xpos[i] <- xpos[i - 1] + sample(move_directions, 1)
                ypos[i] <- ypos[i - 1]
            }  ##If not horizontal, then vertical
 else {
            xpos[i] <- xpos[i - 1]
            ypos[i] <- ypos[i - 1] + sample(move_directions, 1)
        }
    }
    ## return the full trajectory
    return(data.frame(xpos = xpos, ypos = ypos))
}
```

(@) Use `system.time` to time `rand_walk_3` for `n = 1e6`. 

```{r cache = TRUE}
#Time rand_walk_4 here
system.time(rand_walk_4(1e6))
```

(@) What is the ratio of elapsed time for `rand_walk_4` versus `rand_walk_1`?

```{r}
system.time(rand_walk_4(1e6))/system.time(rand_walk_1(1e6))
```


We can eliminate the `for` loop altogether by using `ifelse` and `cumsum`. First some brief examples of these functions in action in a simpler setting.

```{r}
cumsum(1:10)
ifelse(TRUE, "a", "b")
ifelse(FALSE, "a", "b")
```

Here is the next version of the function.

```{r}
rand_walk_5 <- function(n){
  move_horiz <- sample(c(TRUE, FALSE), n-1, replace = TRUE)
  move_directions <- sample(c(-1, 1), n-1, replace = TRUE)
  xpos <- c(0, cumsum(ifelse(move_horiz, move_directions, 0)))
  ypos <- c(0, cumsum(ifelse(move_horiz, 0, move_directions)))
  return(data.frame(xpos = xpos, ypos = ypos))
}
```

(@) Use `system.time` to time `rand_walk_5` for `n = 1e6`. 

```{r}
#Time rand_walk_5 here
system.time(rand_walk_5(1e6))
```

(@) What is the ratio of elapsed time for `rand_walk_6` versus `rand_walk_1`?

```{r}
system.time(rand_walk_5(1e6))/system.time(rand_walk_1(1e6))
```


There are four types of moves:

1.  horizontal, -1
2.  horizontal, +1
3.  vertical, -1
4.  vertical, +1

Instead of separately sampling for horizontal versus vertical and +1 versus -1, we could take one sample from the numbers 1, 2, 3, 4, and have that result specify the move fully. Here's the resulting function.

```{r} 
rand_walk_6 <- function(n){
  move_type <- sample(1:4, n-1, replace = TRUE)
  xmoves <- c(-1, 1, 0, 0)
  ymoves <- c(0, 0, -1, 1)
  xpos = c(0, cumsum(xmoves[move_type]))
  ypos = c(0, cumsum(ymoves[move_type]))
  return(data.frame(xpos = xpos, ypos = ypos))
}
```

(@) Use `system.time` to time `rand_walk_6` for `n = 1e6`. 

```{r}
#Time rand_walk_6 here
system.time(rand_walk_6(1e6))
```

(@) What is the ratio of elapsed time for `rand_walk_6` versus `rand_walk_1`?